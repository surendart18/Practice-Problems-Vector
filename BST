BST Implementation
1.insert
2.search
3.delete
4.display


#include<stdio.h>
#include<stdlib.h>
typedef struct BST
{
        struct BST *left;
        int roll;
        struct BST *right;
}TREE;

void add_tree(TREE **,int);
void pre_order(TREE *);
void post_order(TREE *);
void in_order(TREE *);
TREE *search(TREE *,int);
void delete(TREE **,int);

int main()
{
        TREE *hptr=0;
        char op;
        int roll;
        do
        {
                printf("Enter the roll\n");
                scanf("%d",&roll);
                add_tree(&hptr,roll);
                printf("Do you want to add another record(y/n)\n");
                scanf(" %c",&op);
        }while((op=='y') || (op=='Y'));

        printf("\n Pre_order..\n");
        pre_order(hptr);
        printf("\nIn_order..\n");
        in_order(hptr);
        printf("\nPost_order..\n");
        post_order(hptr);

         printf("\nEnter the roll to search\n");
         scanf("%d",&roll);
         TREE *p=search(hptr,roll);

         if(p==NULL)
                printf("The Data doesn't exist\n");
         else
                printf("The data exist at : %p\n",p);

        printf("Enter the roll to delete\n");
        scanf("%d",&roll);
        delete(&hptr,roll);


        printf("\n Pre_order..\n");
        pre_order(hptr);
        printf("\nIn_order..\n");
        in_order(hptr);
        printf("\nPost_order..\n");
        post_order(hptr);
        printf("\n");
}

void add_tree(TREE **ptr,int n)
{
        if(*ptr==0)
        {
                *ptr=(TREE *)malloc(sizeof(TREE));
                (*ptr)->roll=n;
                (*ptr)->left=(*ptr)->right=0;
        }
        else if(n < (*ptr)->roll)
                add_tree(&(*ptr)->left,n);
        else
                add_tree(&(*ptr)->right,n);
}

TREE *parent;
TREE *search(TREE *ptr,int n)
{
        if(ptr==NULL)
                return NULL;
        else if(n==ptr->roll)
                return ptr;
        else if(n < ptr->roll)
        {
                parent=ptr;
                return search(ptr->left,n);
        }
        else
        {
                parent=ptr;
                return search(ptr->right,n);
        }
}

void pre_order(TREE *ptr)
{
        if(ptr)
        {
                printf("%d ",ptr->roll);
                pre_order(ptr->left);
                pre_order(ptr->right);
        }
}

void in_order(TREE *ptr)
{
        if(ptr)
        {
                in_order(ptr->left);
                printf("%d ",ptr->roll);
                in_order(ptr->right);
        }
}
void post_order(TREE *ptr)
{
        if(ptr)
        {
                post_order(ptr->left);
                post_order(ptr->right);
                printf("%d ",ptr->roll);
        }
}
void delete(TREE **ptr,int roll)
{
        TREE *q=search(*ptr,roll);
        if(q==NULL)
        {
                printf("Data doesn't exist to delete\n");
                return;
        }
        TREE *p=parent;

        if((q->left!=0) && (q->right!=0))
        {
                TREE *r=q->left;
                while(r->right!=0)
                {
                        p=r;
                        r=r->right;
                }
                q->roll=r->roll;
                q=r;
        }

        if((q->left==0) && (q->right==0))
        {
                if(q==p->left)
                        p->left=0;
                else
                        p->right=0;
                free(q);
                q=NULL;
                return;
        }

        if((q->left!=0) && (q->right==0))
        {
                if(q==p->left)
                        p->left=q->left;
                else
                        p->right=q->left;
                free(q);
                q=NULL;
                return;
        }
        if((q->left==0) && (q->right!=0))
        {
                if(q==p->left)
                        p->left=q->right;
                else
                        p->right=q->right;
                free(q);
                q=NULL;
                return;
        }
}
